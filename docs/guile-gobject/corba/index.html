<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>(guile gtk): docs: guile-gobject: corba</title>
  <style type="text/css"><!--
  /* bad netscape four, no stylesheet for you */
  @import url(../../../base.css);
  --></style>
 </head>
 <body>
  <div id="body">
   <div id="heading">

    <h1>(guile gtk)</h1>
    <div id="menu-bar" class="reversed"><a href="../../../">top</a> <a  href="../../../docs/">documentation</a> <a  href="../../../download/">download</a> <a  href="../../../dev/">developers</a> <a  href="../../../contact/">contact</a> <a  href="../../../links/">links</a></div>

   </div>
   <div id="text">

    <h2>(help (gnome corba))</h2>

    <p>
     <strong>Note:</strong> This file is from the 0.2.0 release notes. Somewhere
     between then and 0.5.0, CORBA got broken (I suspect changes in ORBit2 to be
     at fault). Presumably, fixing this would be trivial, but I don't know. I'm
     not a CORBA guru.
    </p>

    <p>
     This module depends heavily on ORBit2 - the ORB which we use in GNOME 2 -
     it doesn't work with any other ORB, but read the bootstraping section
     below.
    </p>

    <h3>Bootstrapping your IDL</h3>

    <p>
     ORBit2 is a CORBA 2.3 compliant ORB - and, of course, it's interoperable
     with other ORBs.
    </p>

    <p>
     However, it's not very useful to have an opaque &lt;CORBA:Object&gt; in scheme if
     you don't know anything about this object. It's also not very useful if you
     can't write your own CORBA servants in scheme.
    </p>

    <p>
     Basically, there are two ways to solve this problem: parsing the IDL at
     runtime or doing it the GNOME 2 way - loading a shared library which
     contains all the necessary information from the IDL.
    </p>

    <p>
     Some of the core GNOME 2 libraries like Bonobo provide so called "imodule"
     libraries which are installed in `$(libdir)/&lt;modulename&gt;_imodule.la'.
    </p>

    <p>
     To create such a library for your own IDL, you need to run ORBit2's IDL
     compiler, orbit-idl, with the --imodule argument - see the demos/corba/
     directory in this distribution for an example.
    </p>

    <p>
     NOTE: The rest of this section refers to the sample IDL which can be found
     in demos/corba/Foo.idl in this distribution.
    </p>

    <p>
     Once you installed this library, you can read it in scheme by calling
    </p>

<pre>
   (corba-primitive-open-module "Foo")
</pre>


    <p>
     This creates all the GOOPS classes and methods you need.
    </p>

    <p>
     If there's a a CORBA interface Foo::Hello, the bootstrap process will
     create a GOOPS class &lt;Foo:Hello&gt; which serves as stub class and another
     GOOPS class &lt;POA:Foo:Hello&gt; which serves as skeleton class.
    </p>

    <p>
     All stub classes are derived from &lt;CORBA:Object&gt; and their CORBA class
     hierarchy is preserved in scheme.
    </p>

    <p>
     All skeleton classes are derived from &lt;PortableServer-ServantBase&gt; and
     their CORBA class hierarchy is preserved as well.
    </p>

    <h3>Calling CORBA Methods</h3>

    <p>
     This section refers to the sample IDL in demos/corba/Foo.idl in this
     distribution.
    </p>

    <p>
     To call a CORBA method, all you need to do is to invoke the corresponding
     method in the stub class - let's assume `hello' is an instance of the
     &lt;Foo:Hello&gt; class:
    </p>

<pre>
   (Foo:Hello:doHello hello) ; calls the CORBA method `Foo::Hello::doHello'
                               on the CORBA Object `hello'.
</pre>

    <p>
     So to call CORBA methods, you don't even need to know that it's CORBA :-)
    </p>

    <p>
     Oh, btw. the cool thing about CORBA and scheme is that you don't need to
     worry about these annoying CORBA exceptions - since you automatically get a
     scheme exception `corba-system-exception' / `corba-user-exception'.
    </p>

    <h3>Implementing CORBA servants</h3>

    <p>
     Well, I guess the interesting part is to implement CORBA servants in scheme
     - so let's assume you want to write a servant for the `Foo::Hello'
     interface.
    </p>

    <p>
     The first thing you need to do is to derive its POA class (as a special
     "feature" you can also use the POA class directly to specify the default
     behavior for all servants of this interface, see below):
    </p>

<pre>
   (define-class &lt;hello&gt; (&lt;POA:Foo:Hello&gt;))
</pre>

    <p>
     Then, you define methods:
    </p>

<pre>
   (define-method (Foo:Hello:doHello (hello &lt;hello&gt;))
     (display (list "Hello World!" hello)) (newline))
</pre>

    <p>
     If you call `(next-method)', the POA classes method will be run - and the
     default is to throw a CORBA::NO_IMPLEMENT system exception.
    </p>

    <p>
     However, you can override this:
    </p>

<pre>
   (define-method (Foo:Bar:Baz:haveFun (object &lt;POA:Foo:Bar:Baz&gt;) a b)
     (display (list "Default Foo:Bar:Baz:haveFun handler!" a b))
     (newline))
</pre>

    <p>
     If you created all the methods, you can create servants and call
     `corba-servant-&gt;reference' to get a CORBA::Object reference:
    </p>

<pre>
   (define servant (make &lt;hello&gt;))
   (define hello (corba-servant-&gt;reference servant))
</pre>

    <p>
     Now you have a CORBA Object `hello' (for guile, this is an instance of the
     GOOPS class &lt;Foo:Hello&gt;) and you can invoke methods on it:
    </p>

<pre>
   (Foo:Hello:doHello hello)
</pre>

    <p>
     Even if this looks like there's just a scheme method being called - this is
     a "real" CORBA call - for scheme `hello' is a "normal" CORBA Object.
    </p>

    <p>
     NOTE: Any CORBA Objects which you create in guile are "owned" by guile's
     garbage collector - so make sure to CORBA_Object_duplicate() in a C
     function before you store it somewhere !
    </p>

    <h3>Implementing CORBA servants - multiple inheritance</h3>

    <p>
     Like in C, you can also create servants for CORBA interfaces which are
     derived from other interfaces:
    </p>

<pre>
   (define-class &lt;maximum&gt; (&lt;hello&gt; &lt;POA:Foo:MaximumHello&gt;))
   (define-method (Foo:Hello:doHello (hello &lt;maximum&gt;))
     (display (list "Hello Maximum World!" hello))
     (newline)
     (next-method))

   (define maximum-servant (make &lt;maximum&gt;))
   (define maximum (corba-servant-&gt;reference maximum-servant))
</pre>

    <p>
     This creates a new servant for the CORBA interface Foo::MaximumHello which
     is derived from Foo::Hello and Foo::Bar::Baz - this inheritance is
     reflected in scheme.
    </p>

<pre>
   ;; Calls method `Foo:Hello:doHello' in class &lt;maximum&gt; and then
   ;; in &lt;hello&gt; because of the (next-method).
   (Foo:Hello:doHello maximum)

   ;; Calls method `Foo:Bar:Baz:haveFun' in class &lt;POA:Foo:Bar:Baz&gt; -
   ;; the default handler.
   (Foo:Bar:Baz:haveFun maximum 1 2)
</pre>

    <p>
     Since we're using real CORBA calls, all of this also works for calls which
     are coming "from the outside" - ie. from C or a remote process.
    </p>

    <h3>Implementing CORBA servants - an important limitation</h3>

    <p>
     CORBA servants can be implemented either in C or in scheme - but you cannot
     mix them - to make it clear, an example:
    </p>

    <p>
     In the example above, you learned how to create a CORBA servant for the
     Foo::MaximumHello CORBA interface in scheme.
    </p>

    <p>
     Now let's assume you already have an implementation for the Foo::Hello
     interface in C.
    </p>

    <p>
     Even if Foo::MaximumHello is derived from Foo::Hello - you cannot use the
     Foo::Hello C implementation in scheme.
    </p>

    <p>
     This limitation may sound obvious, but it's not so obvious at all if you're
     a bit familiar with CORBA. In C, you would normally expect to have a `vepv'
     and a `epv' vector in a CORBA servant - and to be able to poke around in
     the vepv to override methods.
    </p>

    <p>
     As an ORBit2 specific implementation details, servants which you create
     from scheme don't have a `vepv' at all and the `epv' is not what you'd
     expect - the `epv' entries are scheme vectors and not pointers to C
     functions.
    </p>

    <p>
     [Implementation details:
    </p>

    <p>
     This works because ORBit2 has a feature to call one single function to
     marshal any calls on a CORBA object - the `impl_finder_func' and
     `relay_call' fields in the class info (see ORBit2 source code for details).
    </p>

    <p>
     This feature was explicitly added to ORBit2 to make it easy to use from
     scripting languages - it'd be difficult to provide "normal" `epv' entries
     for the scheme methods (you'd have to generate a C function at runtime
     which also contains a data pointer somewhere - before we added this feature
     to ORBit2 I was using weird assembler tricks here and it was also using
     much more memory - about 40 more bytes / CORBA method). ]
    </p>

    <h3>CORBA structs / sequences</h3>

    <p>
     There's support to access CORBA structs / sequences from scheme including a
     special record type for structs - see the (gnome corba) module for details.
    </p>

    <p>
     That's it for the docs. They're not quite adequate -- want to write some
     more? <a href="../../../contact/">Contact us</a>!
    </p>
   </div>

<p></p>
<div class="copyright">
<p>
Copyright (C) 2003 
Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, 
MA 02111, USA
</p>

<p>
Verbatim copying and distribution of this entire article is
permitted in any medium, provided this notice is preserved.
<br />
Updated:

<!-- timestamp start -->
$Date: 2003/10/02 15:19:27 $ $Author: mvo $
<!-- timestamp end -->
</p>
</div>

  </div>
 </body>
</html>
